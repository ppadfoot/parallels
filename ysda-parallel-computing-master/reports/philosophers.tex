\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage[english,russian]{babel}
\usepackage[T1]{fontenc}
\usepackage[left=1.5cm,right=1.5cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{tikz}
\usepackage{pgfplots}

\begin{document}
    \textbf {Выбранный подход}

    Для взятия двух локов был использован $timed\_mutex$ и его метод $try\_lock\_for$.
    Теперь философ, который захотел поесть, будет в цикле сначала пытаться в течение некоторого времени взять левую вилку,
    и в случае успеха попытается в течение некоторого времени взять уже правую вилку.
    Если правую вилку за это время взять удастся, вызовется метод eat(), затем опускаются правая и левая вилка и цикл разрывается,
    в противном случае отпускается левая вилка и цикл продолжается.

    Код в проекте разбит на несколько файлов.
    Вся общая логика для философов вынесена в класс $BasePhilosopher$, логика, описанная выше, реализована в классе $Philosopher$,
    логика из файла-заготовки перенесена в класс $BlockingPhilosopher$.

    \textbf {Тестирование производительности}

    При тестировании производительности  сравнивался алгоритм без защиты от взаимоблокировок (тот, который был в файле заготовке),
    алгоритм с использованием $try\_lock\_for$ с максимальным временем ожидания лока 100 и 10 миллисекунд.

    Все результаты и выводы программ лежат в папке $results$.
    В папке $blocking$ - алгоритм без защиты от взаимоблокировок, в папке $10ms$ - алгоритм с максимальным временем ожидания
    блокировки 10 миллисекунд, в папке $100ms$ - со временем ожидания 100 миллисекунд.

    Смотря на результаты, можно увидеть, что меньше всего философы ожидают, когда максимальное время ожидания - 10 миллисекунд.
    Также видно, что большее количество философов не сильно влияет на время их ожидания и суммарное количество приемов пищи.

    В итоге получились следующие средние значения при пяти философах для алгоритма с максимальным временем ожидания
    10ms, 100ms и алгоритма из заготовки соответственно:

    \begin{enumerate}
        \item 390 приемов пищи и 22000 ms суммарного ожидания
        \item 350 приемов пищи и 25000 ms суммарного ожидания
        \item 320 приемов пищи и 28000 ms суммарного ожидания
    \end{enumerate}

    И такие результаты при ста философах:

    \begin{enumerate}
        \item 410 приемов пищи и 20000 ms суммарного ожидания
        \item 325 приемов пищи и 27000 ms суммарного ожидания
        \item 270 приемов пищи и 33000 ms суммарного ожидания
    \end{enumerate}

    Также были произведены запуски с 10, 20 и 50 философами, результаты этих запусков находятся в папке $results$.
\end{document}